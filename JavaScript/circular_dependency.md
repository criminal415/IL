# Trouble

타입 스크립트로(자바스크립트도 해당) 개인 프로젝트를 진행하던 도중 모듈을 import해서 사용할 때, undefined가 되는 경우가 있었다.

코드상으로 문제가 되지 않았으나 특정 언어나 runtime에 따라 오류가 발생할 수도 있다는 정보를 얻게 되었고, 이는 순환 참조 때문이라는 내용도 함께 알 수 있었다.

간단히 정리하면,
A를 export 시키고 B에서 import해서 모듈을 사용하는데,
B역시 A를 import해서 사용중 이라면, 무한 반복을 막기 위해서 의도적으로 빈 객체를 출력하게 되는 것이다. <br>

![image](https://user-images.githubusercontent.com/90595291/147348457-5b88b5e0-df47-4409-b7bc-a1d54c4100d7.png) <br>

터미널에서도 inside circular dependency Waring을 띄워준다.

node js가 순환참조를 해결하는 과정

1. main.js에서 require('./A')를 만나고 코드 실행을 멈춘 뒤 A.js를 실행한다.
2. A.js를 실행하면서 require('./B')를 만나고 코드 실행을 멈춘 뒤 B.js를 실행한다.
3. B.js를 실행하면서 require('./A')를 만나고 코드 실행을 멈춘 뒤 A.js를 실행한다.
4. 이때 이미 A.js는 실행 중 멈춘 상태라서 실행을 할 수 없다. 그러면 module.exports의 기본 객체인 {}를 반환한다.
5. B.js는 A에 {}를 할당하고 코드 실행을 마무리한다.
6. A.js는 B.js가 내보낸 객체를 받아서 B에 할당하고 이어서 코드 실행을 한다.
7. Node.js를 require()한 파일을 캐싱하므로 실제로는 require('./a')부분에서 두 파일이 모두 읽히고 require('./b')에서는 캐싱된 내용을 가져오게 된다.

# 순환 의존성의 어려운점!

- 실행할 때 오류가 발생하는 게 아니므로 순환 의존성이 존재한다고 하더라도 알아차리기가 어렵다.

- 위에서 본대로 A <-> B 관계에서 require('./A')를 하면 A.js는 정상적인 객체를 받고 B.js가 빈객체를 받는다. 그러므로 테스트 코드를 다 작성하더라도 각 require하는 쪽에서는 보통 문제가 발생하지 않는다. 그래서 애플리케이션을 돌릴 때는 XXX in not a function같은 오류를 볼 수 있지만, 해당 파일을 실제로 돌려보면 아주 잘 돌아간다.

- node로 실행하는 엔트리 파일에서 require하는 순서에 따라 어느 파일에서 빈 객체로 오류가 발생할지 알 수가 없다. require 순서를 바꾸는 것만으로도 다른 곳에서 오류가 발생할 수 있다.

# 해결책

순환 의존성이 발생하면 일차적으로는 모듈화의 설계를 의심해봐야 하고 이로써 해결할 수 있다면 재설계를 해야 한다.

하지만 어쩔 수 없는 때도 있는데 대표적으로 모델 간의 관계를 맺어줄 때이다. 예를 들어 posts.js와 comments.js가 있고 각 파일에서 모델을 정의하고 있다고 할 때(어떤 ORM 라이브러리를 사용하든지) posts.js에서는 comments.js의 모델 객체를 가져와서 hasMany로 선언해야 하고 comments.js에서는 posts.js의 모델 객체를 가져와서 belongsTo로 선언해야 한다. 이런 경우 설계의 문제가 아니지만 모듈 간에 순환 의존성이 생기게 된다. ORM에 따라서 관계정의 부분에서 이러한 문제를 해결하는 방법 등을 제공하기도 하지만 기본적으로 순환 의존성이 생기기 좋은 구조다.

## 해결책 1 (모듈 사용)

madge와 같은 모듈로 순환 의존성을 검사해 볼 수 있다.
큰 해결책은 아니지만, 문제의 가능성이 있는 부분을 확인해 볼 수 있다.

## 해결책 2 (지연 선언)

참조하는 모듈을 module.exports 보다 나중에 선언하여 해결할 수 있지만
보통 require문을 파일에 상단에 선언한다는 관례를 어겨 다른사람이 코드를 읽을 때 불편하며, 모듈 자체내에서 참조해서 써야 하는경우 이 방법을 사용할 수 없다.

## 해결책 3 (exports의 사용)

exports는 동적으로 이 객체에 프로퍼티를 추가한다. 그러므로 결과적으로 양쪽 모듈이 다 실행이 끝나고 나면 정상적인 객체가 완성된다.

![image](https://user-images.githubusercontent.com/90595291/147349921-33d07a50-16a8-4404-aea0-f83c0c4307b8.png) <br>

여기서 a.js나 b.js 상단에서 require()한 객체를 출력해보면 처음엔 빈 객체로 받은 뒤에 프로퍼티가 채워지는 것을 볼 수 있다.

[예제 circular_dependency](https://github.com/criminal415/Practice/tree/main/circular_dependency)
